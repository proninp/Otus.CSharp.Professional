# 17. Порождающие шаблоны проектирования

## Цель:

Создать иерархию из нескольких классов, в которых реализованы методы клонирования объектов по шаблону проектирования "Прототип".

## Описание/Пошаговая инструкция выполнения домашнего задания:

1. Придумать и создать 3-4 класса, которые как минимум дважды наследуются и написать краткое описание текстом.
2. Создать свой дженерик интерфейс `IMyCloneable` для реализации шаблона "Прототип".
3. Сделать возможность клонирования объекта для каждого из этих классов, используя вызовы родительских конструкторов.
4. Составить тесты или написать программу для демонстрации функции клонирования.
5. Добавить к каждому классу реализацию стандартного интерфейса `ICloneable` и реализовать его функционал через уже созданные методы.
6. Написать вывод: какие преимущества и недостатки у каждого из интерфейсов: `IMyCloneable` и `ICloneable`.


## Критерии оценки:

* 2 балла: есть краткое описание созданных классов;
* 2 балла: реализован шаблон проектирования Prototype с пользовательским интерфейсом;
* 2 балла: реализован шаблон проектирования Prototype со стандартным интерфейсом;
* 1 балла: созданы тесты/написано тестирование функционала;
* 2 балла: написан вывод о преимуществах и недостатках каждого метода;
* 1 балл: соблюдение CodeStyle, грамотная архитектура, всё замечания проверяющего исправлены.

Минимальный проходной балл: 8 баллов.

## Выводы


### Анализ интерфейса IMyCloneable<T>

#### Преимущества:

**1. Типобезопасность**
- Возвращает конкретный тип `T` вместо `object`, что исключает необходимость приведения типов;
- Компилятор может проверить корректность использования на этапе компиляции - отсутствие `InvalidCastException` во время выполнения;

**2. Удобство использования**
```csharp
var clonedWarrior = originalWarrior.Clone(); // Сразу получаем Warrior
// Вместо: var clonedWarrior = (Warrior)originalWarrior.Clone();
```

#### Недостатки:

**1. Отсутствие стандартизации**
- Не является частью .NET Framework/Core;
- Другие разработчики могут быть не знакомы с этим интерфейсом;

**2. Ограниченная совместимость**
- Не работает с существующими библиотеками, ожидающими `ICloneable`;
- Может потребоваться дополнительная реализация стандартного интерфейса;


### Анализ интерфейса ICloneable

#### Преимущества:

**1. Стандартизация**
- Является частью .NET Base Class Library;
- Широко известен и понятен всем .NET разработчикам;
- Стандартный подход в экосистеме .NET;

**2. Совместимость**
- Поддерживается всеми существующими библиотеками и фреймворками;
- Работает с универсальными алгоритмами, ожидающими этот интерфейс;

**3. Полиморфизм**
- Можно работать с коллекциями объектов разных типов через единый интерфейс:

```csharp
ICloneable[] objects = { warrior, mage, necromant };
var clones = objects.Select(obj => obj.Clone()).ToArray();
```

#### Недостатки:

**1. Отсутствие типобезопасности**
- Возвращает `object`, требуя явного приведения типов;
- Возможны ошибки `InvalidCastException` во время выполнения;
- Компилятор не может проверить корректность приведения типов;

**2. Неудобство использования**
```csharp
var clonedWarrior = (Warrior)originalWarrior.Clone(); // Необходимо приведение
```


### Рекомендации по использованию

`IMyCloneable<T>`:
в новых проектах, где типобезопасность критична, когда производительность и отсутствие boxing/unboxing важны, либо в generic-коде, где тип известен на этапе компиляции.

`ICloneable`:
при необходимости совместимости с существующими библиотеками, в публичных API, которые будут использоваться сторонними разработчиками, при работе с legacy-кодом, а так же когда требуется полиморфное поведение с объектами разных типов.